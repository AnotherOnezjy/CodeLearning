# 数据结构——单调栈

## 单调栈介绍

### 什么是单调栈

&emsp;&emsp;单调栈是数据结构的一种变形，在满足栈先进后出（FILO）的条件下，还要满足栈内元素遵循单调性，比如从栈底到栈顶元素保持递增的单调递增栈。<br>

### 如何维护单调栈

&emsp;&emsp;以维护一个单调递增栈为例。<br>
&emsp;&emsp;当插入一个新元素时，为了维护栈内的单调性，我们将该元素与栈顶元素进行比较，若不满足单调性，就将栈顶元素弹出，不断重复，直到栈空或者满足单调性为止，最后再将该元素加入栈，使之成为栈顶。<br>
&emsp;&emsp;参考代码如下：

-   c++ STL 版本

```c++
for (int i = 1; i <= n; i++) {
    while (!stk.empty() && stk.top() >= a[i]) stk.pop();
    stk.push(a[i]);
}//c++ stl
```

-   一维数组版本

```c++
for (int i = 1; i <= n; i++) {
    while (top > 0 && stk[top] >= a[i]) --top;
    stk[++top] = a[i];
}//数组
```

&emsp;&emsp;实际上，我们更多地用单调栈保存元素的下标，而并非其值：

-   c++ STL 版本

```c++
for (int i = 1; i <= n; i++) {
    while (!stk.empty() && a[stk.top()] >= a[i]) stk.pop();
    stk.push(i);
}//c++ stl
```

-   一维数组版本

```c++
for (int i = 1; i <= n; i++) {
    while (top > 0 && a[stk[top]] >= a[i]) --top;
    stk[++top] = i;
}//数组
```

&emsp;&emsp;从这里也可以看出，所谓的“单调”并不仅限于元素的大小关系，只要栈内的元素满足某一类方式上的“有序”即可。

### 单调栈的应用

&emsp;&emsp;单调栈最经典的应用，就是在一个数列里寻找**距离元素最近的比其大（或小）的元素位置**。<br>
&emsp;&emsp;不妨看这个例子：

<center><b>对数列的每个元素，寻找其左侧第一个比它大的元素位置</b></center><br>

&emsp;&emsp;显而易见的，我们可以遍历每个元素，然后从其位置开始往左查找，这种暴力做法的时间复杂度是 _O(n$^2$)_。<br>
&emsp;&emsp;那么使用单调栈呢？我们只需要从右往左遍历，依次将元素加入单调栈中，维护一个从栈底到栈顶**递减**的单调栈。当某个元素被弹出时，代表它遇到了一个比它更大的元素，因为是从右往左遍历，所以这个遇到的元素就是第一个比它大的元素，即所求。如果某个元素最后仍在栈内，说明它的左侧没有比它更大的元素。<br>
&emsp;&emsp;整理一下思路：从右往左遍历元素，如果栈为空或者栈顶元素比它大，就将这个元素入栈；否则将栈顶元素退栈，如果退栈的元素是目标元素，那么当前遍历到的元素即为所求，否则持续退栈直到栈为空或者栈顶元素大于当前遍历到的元素……<br>
&emsp;&emsp;遍历的时间复杂度是 _O(n)_，每个元素最多被加入单调栈一次、弹出来一次，所以从时间复杂度是 _O(n)_。<br>
&emsp;&emsp;对于这类问题，我们可以列出一个简单的表格：
| 问题类型 | 遍历方向 | 维护单调性（栈底 -> 栈顶） |
| :-: | :-: | :-: |
| 左侧第一个更大元素 | 从右到左 | 单调递减 |
| 左侧第一个更小元素 | 从右到左 | 单调递增 |
| 右侧第一个更大元素 | 从左到右 | 单调递减 |
| 右侧第一个更小元素 | 从左到右 | 单调递增 |

## 拓展内容

## 拓展一：如何寻找左侧第二个比当前元素大的元素位置

&emsp;&emsp;来看一道题：一列人在排队，身高有高有矮，每个人可以插队无限次比自己矮的人，但仅仅可以插队一次比自己高的人。如果只有一个人插队，这个人最多可以排到多前面？<br>
&emsp;&emsp;不难看出，答案就是左侧第二个比目标元素大的元素位置 + 1。但问题来了，如何定位到这里呢？直接应用单调栈可以简单快速求解**第一个**这样的元素，而**第二个**却无能为力。<br>
&emsp;&emsp;这里我们可以采用**维护两个单调栈**的方法。当元素被第一个单调栈弹出时，将其加入第二个单调栈，当其再次被弹出的时候遇到的就是答案。这里第二个单调栈的维护需要一点小技巧，由于栈先进后出的特性，我们需要把从第一个单调栈取出的元素先加入一个临时栈，再从临时栈把它们加入第二个单调栈，以维持单调性。<br>
&emsp;&emsp;这样一来，每个元素最多被入栈三次，出栈三次，总时间复杂度还是 _O(n)_ 级别的。<br>

题目链接：[ACM 基地招新大会](https://ac.nowcoder.com/acm/contest/11290/I)
邀请码：39sohrnqz46
参考代码：

```c++
#include<cstdio>
#include<stack>

using namespace std;
const int maxn = 1e5 + 10;
int n;

stack<int> stk1, stk2, stk3;
int a[maxn], ans[maxn];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = n; i >= 1; i--) {
        while (!stk2.empty() && a[stk2.top()] < a[i]) {
            ans[stk2.top()] = i + 1;
            stk2.pop();
        }
        while (!stk1.empty() && a[stk1.top()] < a[i]) {
            stk3.push(stk1.top());
            stk1.pop();
        }
        stk1.push(i);
        while (!stk3.empty()) stk2.push(stk3.top()), stk3.pop();
    }
    while (!stk1.empty()) ans[stk1.top()] = 1, stk1.pop();
    while (!stk2.empty()) ans[stk2.top()] = 1, stk2.pop();
    for (int i = 1; i <= n; i++) printf("%d\n", ans[i]);
    return 0;
}
```

## 拓展二：如何寻找左侧第 k 个比当前元素大的元素位置

&emsp;&emsp;这就是整个问题最终的拓展了。简单地想，就是维护 k 个单调栈，每次元素从一个栈弹出就进入下一个栈，最后一次被弹出就是找到了答案，时间复杂度是 _O(kn)_ 级别的，但这样写过于麻烦了。<br>
&emsp;&emsp;如果不计较时间复杂度，可以维护一个优先队列，每次把小于当前元素的值都取出来，将其计数器加一再放回去，然后把当前元素也加入优先队列。当计数器为 k 时，取出来就不再放回，而是记录答案。这样的话，每个元素最多取出来 k 次，塞进去 k 次，总的时间复杂度是 _O(knlogn)_ 级别。<br>
&emsp;&emsp;当然，在 k 较大时，完全可以直接使用暴力解法，时间复杂度的上限为 _O(n$^2$)_。
